/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/assets/{id}': {
    /** Image typed files can be dynamically resized and transformed to fit any need. */
    get: operations['getAsset'];
  };
  '/auth/login': {
    /** Retrieve a Temporary Access Token */
    post: operations['login'];
  };
  '/auth/refresh': {
    /** Refresh a Temporary Access Token. */
    post: operations['refresh'];
  };
  '/auth/logout': {
    /** Log Out */
    post: operations['logout'];
  };
  '/auth/password/request': {
    /** Request a reset password email to be send. */
    post: operations['passwordRequest'];
  };
  '/auth/password/reset': {
    /** The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password. */
    post: operations['passwordReset'];
  };
  '/auth/oauth': {
    /** List configured OAuth providers. */
    get: operations['oauth'];
  };
  '/auth/oauth/{provider}': {
    /** Start OAuth flow using the specified provider */
    get: operations['oauthProvider'];
  };
  '/extensions/interfaces': {
    /** List all installed custom interfaces. */
    get: operations['getInterfaces'];
  };
  '/extensions/layouts': {
    /** List all installed custom layouts. */
    get: operations['getLayouts'];
  };
  '/extensions/displays': {
    /** List all installed custom displays. */
    get: operations['getDisplays'];
  };
  '/extensions/modules': {
    /** List all installed custom modules. */
    get: operations['getModules'];
  };
  '/server/info': {
    /** Perform a system status check and return the options. */
    get: operations['serverInfo'];
  };
  '/server/ping': {
    /** Ping, pong. Ping.. pong. */
    get: operations['ping'];
  };
  '/utils/random/string': {
    /** Returns a random string of given length. */
    get: operations['random'];
  };
  '/utils/sort/{collection}': {
    /** Re-sort items in collection based on start and to value of item */
    post: operations['sort'];
  };
  '/items/article': {
    /** List the article items. */
    get: operations['readItemsArticle'];
    /** Create a new article item. */
    post: operations['createItemsArticle'];
  };
  '/items/article/{id}': {
    /** Retrieve a single article item by unique identifier. */
    get: operations['readSingleItemsArticle'];
    /** Delete an existing article item. */
    delete: operations['deleteSingleItemsArticle'];
    /** Update an existing article item. */
    patch: operations['updateSingleItemsArticle'];
  };
  '/items/article_category': {
    /** List the article_category items. */
    get: operations['readItemsArticleCategory'];
    /** Create a new article_category item. */
    post: operations['createItemsArticleCategory'];
  };
  '/items/article_category/{id}': {
    /** Retrieve a single article_category item by unique identifier. */
    get: operations['readSingleItemsArticleCategory'];
    /** Delete an existing article_category item. */
    delete: operations['deleteSingleItemsArticleCategory'];
    /** Update an existing article_category item. */
    patch: operations['updateSingleItemsArticleCategory'];
  };
  '/items/article_category_pivot': {
    /** List the article_category_pivot items. */
    get: operations['readItemsArticleCategoryPivot'];
    /** Create a new article_category_pivot item. */
    post: operations['createItemsArticleCategoryPivot'];
  };
  '/items/article_category_pivot/{id}': {
    /** Retrieve a single article_category_pivot item by unique identifier. */
    get: operations['readSingleItemsArticleCategoryPivot'];
    /** Delete an existing article_category_pivot item. */
    delete: operations['deleteSingleItemsArticleCategoryPivot'];
    /** Update an existing article_category_pivot item. */
    patch: operations['updateSingleItemsArticleCategoryPivot'];
  };
  '/items/audio': {
    /** List the audio items. */
    get: operations['readItemsAudio'];
    /** Create a new audio item. */
    post: operations['createItemsAudio'];
  };
  '/items/audio/{id}': {
    /** Retrieve a single audio item by unique identifier. */
    get: operations['readSingleItemsAudio'];
    /** Delete an existing audio item. */
    delete: operations['deleteSingleItemsAudio'];
    /** Update an existing audio item. */
    patch: operations['updateSingleItemsAudio'];
  };
  '/items/audio_category': {
    /** List the audio_category items. */
    get: operations['readItemsAudioCategory'];
    /** Create a new audio_category item. */
    post: operations['createItemsAudioCategory'];
  };
  '/items/audio_category/{id}': {
    /** Retrieve a single audio_category item by unique identifier. */
    get: operations['readSingleItemsAudioCategory'];
    /** Delete an existing audio_category item. */
    delete: operations['deleteSingleItemsAudioCategory'];
    /** Update an existing audio_category item. */
    patch: operations['updateSingleItemsAudioCategory'];
  };
  '/items/audio_category_pivot': {
    /** List the audio_category_pivot items. */
    get: operations['readItemsAudioCategoryPivot'];
    /** Create a new audio_category_pivot item. */
    post: operations['createItemsAudioCategoryPivot'];
  };
  '/items/audio_category_pivot/{id}': {
    /** Retrieve a single audio_category_pivot item by unique identifier. */
    get: operations['readSingleItemsAudioCategoryPivot'];
    /** Delete an existing audio_category_pivot item. */
    delete: operations['deleteSingleItemsAudioCategoryPivot'];
    /** Update an existing audio_category_pivot item. */
    patch: operations['updateSingleItemsAudioCategoryPivot'];
  };
  '/items/book': {
    /** List the book items. */
    get: operations['readItemsBook'];
    /** Create a new book item. */
    post: operations['createItemsBook'];
  };
  '/items/book/{id}': {
    /** Retrieve a single book item by unique identifier. */
    get: operations['readSingleItemsBook'];
    /** Delete an existing book item. */
    delete: operations['deleteSingleItemsBook'];
    /** Update an existing book item. */
    patch: operations['updateSingleItemsBook'];
  };
  '/items/book_author': {
    /** List the book_author items. */
    get: operations['readItemsBookAuthor'];
    /** Create a new book_author item. */
    post: operations['createItemsBookAuthor'];
  };
  '/items/book_author/{id}': {
    /** Retrieve a single book_author item by unique identifier. */
    get: operations['readSingleItemsBookAuthor'];
    /** Delete an existing book_author item. */
    delete: operations['deleteSingleItemsBookAuthor'];
    /** Update an existing book_author item. */
    patch: operations['updateSingleItemsBookAuthor'];
  };
  '/items/book_category': {
    /** List the book_category items. */
    get: operations['readItemsBookCategory'];
    /** Create a new book_category item. */
    post: operations['createItemsBookCategory'];
  };
  '/items/book_category/{id}': {
    /** Retrieve a single book_category item by unique identifier. */
    get: operations['readSingleItemsBookCategory'];
    /** Delete an existing book_category item. */
    delete: operations['deleteSingleItemsBookCategory'];
    /** Update an existing book_category item. */
    patch: operations['updateSingleItemsBookCategory'];
  };
  '/items/book_category_pivot': {
    /** List the book_category_pivot items. */
    get: operations['readItemsBookCategoryPivot'];
    /** Create a new book_category_pivot item. */
    post: operations['createItemsBookCategoryPivot'];
  };
  '/items/book_category_pivot/{id}': {
    /** Retrieve a single book_category_pivot item by unique identifier. */
    get: operations['readSingleItemsBookCategoryPivot'];
    /** Delete an existing book_category_pivot item. */
    delete: operations['deleteSingleItemsBookCategoryPivot'];
    /** Update an existing book_category_pivot item. */
    patch: operations['updateSingleItemsBookCategoryPivot'];
  };
  '/items/comment': {
    /** List the comment items. */
    get: operations['readItemsComment'];
    /** Create a new comment item. */
    post: operations['createItemsComment'];
  };
  '/items/comment/{id}': {
    /** Retrieve a single comment item by unique identifier. */
    get: operations['readSingleItemsComment'];
    /** Delete an existing comment item. */
    delete: operations['deleteSingleItemsComment'];
    /** Update an existing comment item. */
    patch: operations['updateSingleItemsComment'];
  };
  '/items/comment_entity': {
    /** List the comment_entity items. */
    get: operations['readItemsCommentEntity'];
    /** Create a new comment_entity item. */
    post: operations['createItemsCommentEntity'];
  };
  '/items/comment_entity/{id}': {
    /** Retrieve a single comment_entity item by unique identifier. */
    get: operations['readSingleItemsCommentEntity'];
    /** Delete an existing comment_entity item. */
    delete: operations['deleteSingleItemsCommentEntity'];
    /** Update an existing comment_entity item. */
    patch: operations['updateSingleItemsCommentEntity'];
  };
  '/items/document': {
    /** List the document items. */
    get: operations['readItemsDocument'];
    /** Create a new document item. */
    post: operations['createItemsDocument'];
  };
  '/items/document/{id}': {
    /** Retrieve a single document item by unique identifier. */
    get: operations['readSingleItemsDocument'];
    /** Delete an existing document item. */
    delete: operations['deleteSingleItemsDocument'];
    /** Update an existing document item. */
    patch: operations['updateSingleItemsDocument'];
  };
  '/items/document_category': {
    /** List the document_category items. */
    get: operations['readItemsDocumentCategory'];
    /** Create a new document_category item. */
    post: operations['createItemsDocumentCategory'];
  };
  '/items/document_category/{id}': {
    /** Retrieve a single document_category item by unique identifier. */
    get: operations['readSingleItemsDocumentCategory'];
    /** Delete an existing document_category item. */
    delete: operations['deleteSingleItemsDocumentCategory'];
    /** Update an existing document_category item. */
    patch: operations['updateSingleItemsDocumentCategory'];
  };
  '/items/document_category_pivot': {
    /** List the document_category_pivot items. */
    get: operations['readItemsDocumentCategoryPivot'];
    /** Create a new document_category_pivot item. */
    post: operations['createItemsDocumentCategoryPivot'];
  };
  '/items/document_category_pivot/{id}': {
    /** Retrieve a single document_category_pivot item by unique identifier. */
    get: operations['readSingleItemsDocumentCategoryPivot'];
    /** Delete an existing document_category_pivot item. */
    delete: operations['deleteSingleItemsDocumentCategoryPivot'];
    /** Update an existing document_category_pivot item. */
    patch: operations['updateSingleItemsDocumentCategoryPivot'];
  };
  '/items/image': {
    /** List the image items. */
    get: operations['readItemsImage'];
    /** Create a new image item. */
    post: operations['createItemsImage'];
  };
  '/items/image/{id}': {
    /** Retrieve a single image item by unique identifier. */
    get: operations['readSingleItemsImage'];
    /** Delete an existing image item. */
    delete: operations['deleteSingleItemsImage'];
    /** Update an existing image item. */
    patch: operations['updateSingleItemsImage'];
  };
  '/items/image_category': {
    /** List the image_category items. */
    get: operations['readItemsImageCategory'];
    /** Create a new image_category item. */
    post: operations['createItemsImageCategory'];
  };
  '/items/image_category/{id}': {
    /** Retrieve a single image_category item by unique identifier. */
    get: operations['readSingleItemsImageCategory'];
    /** Delete an existing image_category item. */
    delete: operations['deleteSingleItemsImageCategory'];
    /** Update an existing image_category item. */
    patch: operations['updateSingleItemsImageCategory'];
  };
  '/items/image_category_pivot': {
    /** List the image_category_pivot items. */
    get: operations['readItemsImageCategoryPivot'];
    /** Create a new image_category_pivot item. */
    post: operations['createItemsImageCategoryPivot'];
  };
  '/items/image_category_pivot/{id}': {
    /** Retrieve a single image_category_pivot item by unique identifier. */
    get: operations['readSingleItemsImageCategoryPivot'];
    /** Delete an existing image_category_pivot item. */
    delete: operations['deleteSingleItemsImageCategoryPivot'];
    /** Update an existing image_category_pivot item. */
    patch: operations['updateSingleItemsImageCategoryPivot'];
  };
  '/items/institute': {
    /** List the institute items. */
    get: operations['readItemsInstitute'];
    /** Create a new institute item. */
    post: operations['createItemsInstitute'];
  };
  '/items/institute/{id}': {
    /** Retrieve a single institute item by unique identifier. */
    get: operations['readSingleItemsInstitute'];
    /** Delete an existing institute item. */
    delete: operations['deleteSingleItemsInstitute'];
    /** Update an existing institute item. */
    patch: operations['updateSingleItemsInstitute'];
  };
  '/items/menu': {
    /** List the menu items. */
    get: operations['readItemsMenu'];
    /** Create a new menu item. */
    post: operations['createItemsMenu'];
  };
  '/items/menu/{id}': {
    /** Retrieve a single menu item by unique identifier. */
    get: operations['readSingleItemsMenu'];
    /** Delete an existing menu item. */
    delete: operations['deleteSingleItemsMenu'];
    /** Update an existing menu item. */
    patch: operations['updateSingleItemsMenu'];
  };
  '/items/page': {
    /** List the page items. */
    get: operations['readItemsPage'];
    /** Create a new page item. */
    post: operations['createItemsPage'];
  };
  '/items/page/{id}': {
    /** Retrieve a single page item by unique identifier. */
    get: operations['readSingleItemsPage'];
    /** Delete an existing page item. */
    delete: operations['deleteSingleItemsPage'];
    /** Update an existing page item. */
    patch: operations['updateSingleItemsPage'];
  };
  '/items/question': {
    /** List the question items. */
    get: operations['readItemsQuestion'];
    /** Create a new question item. */
    post: operations['createItemsQuestion'];
  };
  '/items/question/{id}': {
    /** Retrieve a single question item by unique identifier. */
    get: operations['readSingleItemsQuestion'];
    /** Delete an existing question item. */
    delete: operations['deleteSingleItemsQuestion'];
    /** Update an existing question item. */
    patch: operations['updateSingleItemsQuestion'];
  };
  '/items/question_category': {
    /** List the question_category items. */
    get: operations['readItemsQuestionCategory'];
    /** Create a new question_category item. */
    post: operations['createItemsQuestionCategory'];
  };
  '/items/question_category/{id}': {
    /** Retrieve a single question_category item by unique identifier. */
    get: operations['readSingleItemsQuestionCategory'];
    /** Delete an existing question_category item. */
    delete: operations['deleteSingleItemsQuestionCategory'];
    /** Update an existing question_category item. */
    patch: operations['updateSingleItemsQuestionCategory'];
  };
  '/items/question_category_pivot': {
    /** List the question_category_pivot items. */
    get: operations['readItemsQuestionCategoryPivot'];
    /** Create a new question_category_pivot item. */
    post: operations['createItemsQuestionCategoryPivot'];
  };
  '/items/question_category_pivot/{id}': {
    /** Retrieve a single question_category_pivot item by unique identifier. */
    get: operations['readSingleItemsQuestionCategoryPivot'];
    /** Delete an existing question_category_pivot item. */
    delete: operations['deleteSingleItemsQuestionCategoryPivot'];
    /** Update an existing question_category_pivot item. */
    patch: operations['updateSingleItemsQuestionCategoryPivot'];
  };
  '/items/question_type': {
    /** List the question_type items. */
    get: operations['readItemsQuestionType'];
    /** Create a new question_type item. */
    post: operations['createItemsQuestionType'];
  };
  '/items/question_type/{id}': {
    /** Retrieve a single question_type item by unique identifier. */
    get: operations['readSingleItemsQuestionType'];
    /** Delete an existing question_type item. */
    delete: operations['deleteSingleItemsQuestionType'];
    /** Update an existing question_type item. */
    patch: operations['updateSingleItemsQuestionType'];
  };
  '/items/reaction': {
    /** List the reaction items. */
    get: operations['readItemsReaction'];
    /** Create a new reaction item. */
    post: operations['createItemsReaction'];
  };
  '/items/reaction/{id}': {
    /** Retrieve a single reaction item by unique identifier. */
    get: operations['readSingleItemsReaction'];
    /** Delete an existing reaction item. */
    delete: operations['deleteSingleItemsReaction'];
    /** Update an existing reaction item. */
    patch: operations['updateSingleItemsReaction'];
  };
  '/items/reaction_entity': {
    /** List the reaction_entity items. */
    get: operations['readItemsReactionEntity'];
    /** Create a new reaction_entity item. */
    post: operations['createItemsReactionEntity'];
  };
  '/items/reaction_entity/{id}': {
    /** Retrieve a single reaction_entity item by unique identifier. */
    get: operations['readSingleItemsReactionEntity'];
    /** Delete an existing reaction_entity item. */
    delete: operations['deleteSingleItemsReactionEntity'];
    /** Update an existing reaction_entity item. */
    patch: operations['updateSingleItemsReactionEntity'];
  };
  '/items/reaction_type': {
    /** List the reaction_type items. */
    get: operations['readItemsReactionType'];
    /** Create a new reaction_type item. */
    post: operations['createItemsReactionType'];
  };
  '/items/reaction_type/{id}': {
    /** Retrieve a single reaction_type item by unique identifier. */
    get: operations['readSingleItemsReactionType'];
    /** Delete an existing reaction_type item. */
    delete: operations['deleteSingleItemsReactionType'];
    /** Update an existing reaction_type item. */
    patch: operations['updateSingleItemsReactionType'];
  };
  '/items/section': {
    /** List the section items. */
    get: operations['readItemsSection'];
    /** Create a new section item. */
    post: operations['createItemsSection'];
  };
  '/items/section/{id}': {
    /** Retrieve a single section item by unique identifier. */
    get: operations['readSingleItemsSection'];
    /** Delete an existing section item. */
    delete: operations['deleteSingleItemsSection'];
    /** Update an existing section item. */
    patch: operations['updateSingleItemsSection'];
  };
  '/items/theme': {
    /** List the theme items. */
    get: operations['readItemsTheme'];
    /** Create a new theme item. */
    post: operations['createItemsTheme'];
  };
  '/items/theme/{id}': {
    /** Retrieve a single theme item by unique identifier. */
    get: operations['readSingleItemsTheme'];
    /** Delete an existing theme item. */
    delete: operations['deleteSingleItemsTheme'];
    /** Update an existing theme item. */
    patch: operations['updateSingleItemsTheme'];
  };
  '/items/theme_page': {
    /** List the theme_page items. */
    get: operations['readItemsThemePage'];
    /** Create a new theme_page item. */
    post: operations['createItemsThemePage'];
  };
  '/items/theme_page/{id}': {
    /** Retrieve a single theme_page item by unique identifier. */
    get: operations['readSingleItemsThemePage'];
    /** Delete an existing theme_page item. */
    delete: operations['deleteSingleItemsThemePage'];
    /** Update an existing theme_page item. */
    patch: operations['updateSingleItemsThemePage'];
  };
  '/items/theme_page_section': {
    /** List the theme_page_section items. */
    get: operations['readItemsThemePageSection'];
    /** Create a new theme_page_section item. */
    post: operations['createItemsThemePageSection'];
  };
  '/items/theme_page_section/{id}': {
    /** Retrieve a single theme_page_section item by unique identifier. */
    get: operations['readSingleItemsThemePageSection'];
    /** Delete an existing theme_page_section item. */
    delete: operations['deleteSingleItemsThemePageSection'];
    /** Update an existing theme_page_section item. */
    patch: operations['updateSingleItemsThemePageSection'];
  };
  '/items/video': {
    /** List the video items. */
    get: operations['readItemsVideo'];
    /** Create a new video item. */
    post: operations['createItemsVideo'];
  };
  '/items/video/{id}': {
    /** Retrieve a single video item by unique identifier. */
    get: operations['readSingleItemsVideo'];
    /** Delete an existing video item. */
    delete: operations['deleteSingleItemsVideo'];
    /** Update an existing video item. */
    patch: operations['updateSingleItemsVideo'];
  };
  '/items/video_category': {
    /** List the video_category items. */
    get: operations['readItemsVideoCategory'];
    /** Create a new video_category item. */
    post: operations['createItemsVideoCategory'];
  };
  '/items/video_category/{id}': {
    /** Retrieve a single video_category item by unique identifier. */
    get: operations['readSingleItemsVideoCategory'];
    /** Delete an existing video_category item. */
    delete: operations['deleteSingleItemsVideoCategory'];
    /** Update an existing video_category item. */
    patch: operations['updateSingleItemsVideoCategory'];
  };
  '/items/video_category_pivot': {
    /** List the video_category_pivot items. */
    get: operations['readItemsVideoCategoryPivot'];
    /** Create a new video_category_pivot item. */
    post: operations['createItemsVideoCategoryPivot'];
  };
  '/items/video_category_pivot/{id}': {
    /** Retrieve a single video_category_pivot item by unique identifier. */
    get: operations['readSingleItemsVideoCategoryPivot'];
    /** Delete an existing video_category_pivot item. */
    delete: operations['deleteSingleItemsVideoCategoryPivot'];
    /** Update an existing video_category_pivot item. */
    patch: operations['updateSingleItemsVideoCategoryPivot'];
  };
  '/items/website': {
    /** List the website items. */
    get: operations['readItemsWebsite'];
    /** Create a new website item. */
    post: operations['createItemsWebsite'];
  };
  '/items/website/{id}': {
    /** Retrieve a single website item by unique identifier. */
    get: operations['readSingleItemsWebsite'];
    /** Delete an existing website item. */
    delete: operations['deleteSingleItemsWebsite'];
    /** Update an existing website item. */
    patch: operations['updateSingleItemsWebsite'];
  };
  '/activity': {
    /** Returns a list of activity actions. */
    get: operations['getActivities'];
  };
  '/activity/comment': {
    /** Creates a new comment. */
    post: operations['createComment'];
  };
  '/activity/{id}': {
    /** Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information. */
    get: operations['getActivity'];
  };
  '/activity/comment/{id}': {
    /** Delete an existing comment. Deleted comments can not be retrieved. */
    delete: operations['deleteComment'];
    /** Update the content of an existing comment. */
    patch: operations['updateComment'];
  };
  '/collections': {
    /** Returns a list of the collections available in the project. */
    get: operations['getCollections'];
    /** Create a new collection in Directus. */
    post: operations['createCollection'];
  };
  '/collections/{id}': {
    /** Retrieves the details of a single collection. */
    get: operations['getCollection'];
    /** Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution. */
    delete: operations['deleteCollection'];
    /** Update an existing collection. */
    patch: operations['updateCollection'];
  };
  '/fields': {
    /** Returns a list of the fields available in the project. */
    get: operations['getFields'];
  };
  '/fields/{collection}': {
    /** Returns a list of the fields available in the given collection. */
    get: operations['getCollectionFields'];
    /** Create a new field in a given collection. */
    post: operations['createField'];
  };
  '/fields/{collection}/{id}': {
    /** Retrieves the details of a single field in a given collection. */
    get: operations['getCollectionField'];
    /** Delete an existing field. */
    delete: operations['deleteField'];
    /** Update an existing field. */
    patch: operations['updateField'];
  };
  '/files': {
    /** List the files. */
    get: operations['getFiles'];
    /** Create a new file */
    post: operations['createFile'];
  };
  '/files/{id}': {
    /** Retrieve a single file by unique identifier. */
    get: operations['getFile'];
    /** Delete an existing file. */
    delete: operations['deleteFile'];
    /** Update an existing file. */
    patch: operations['updateFile'];
  };
  '/folders': {
    /** List the folders. */
    get: operations['getFolders'];
    /** Create a new folder. */
    post: operations['createFolder'];
  };
  '/folders/{id}': {
    /** Retrieve a single folder by unique identifier. */
    get: operations['getFolder'];
    /** Delete an existing folder */
    delete: operations['deleteFolder'];
    /** Update an existing folder */
    patch: operations['updateFolder'];
  };
  '/permissions': {
    /** List all permissions. */
    get: operations['getPermissions'];
    /** Create a new permission. */
    post: operations['createPermission'];
  };
  '/permissions/me': {
    /** List the permissions that apply to the current user. */
    get: operations['getMyPermissions'];
  };
  '/permissions/{id}': {
    /** Retrieve a single permissions object by unique identifier. */
    get: operations['getPermission'];
    /** Delete an existing permission */
    delete: operations['deletePermission'];
    /** Update an existing permission */
    patch: operations['updatePermission'];
  };
  '/presets': {
    /** List the presets. */
    get: operations['getPresets'];
    /** Create a new preset. */
    post: operations['createPreset'];
  };
  '/presets/{id}': {
    /** Retrieve a single preset by unique identifier. */
    get: operations['getPreset'];
    /** Delete an existing preset. */
    delete: operations['deletePreset'];
    /** Update an existing preset. */
    patch: operations['updatePreset'];
  };
  '/relations': {
    /** List the relations. */
    get: operations['getRelations'];
    /** Create a new relation. */
    post: operations['createRelation'];
  };
  '/relations/{id}': {
    /** Retrieve a single relation by unique identifier. */
    get: operations['getRelation'];
    /** Delete an existing relation. */
    delete: operations['deleteRelation'];
    /** Update an existing relation */
    patch: operations['updateRelation'];
  };
  '/revisions': {
    /** List the revisions. */
    get: operations['getRevisions'];
  };
  '/revisions/{id}': {
    /** Retrieve a single revision by unique identifier. */
    get: operations['getRevision'];
  };
  '/roles': {
    /** List the roles. */
    get: operations['getRoles'];
    /** Create a new role. */
    post: operations['createRole'];
  };
  '/roles/{id}': {
    /** Retrieve a single role by unique identifier. */
    get: operations['getRole'];
    /** Delete an existing role */
    delete: operations['deleteRole'];
    /** Update an existing role */
    patch: operations['updateRole'];
  };
  '/settings': {
    /** List the settings. */
    get: operations['getSettings'];
    /** Update the settings */
    patch: operations['updateSetting'];
  };
  '/users': {
    /** List the users. */
    get: operations['getUsers'];
    /** Create a new user. */
    post: operations['createUser'];
  };
  '/users/{id}': {
    /** Retrieve a single user by unique identifier. */
    get: operations['getUser'];
    /** Delete an existing user */
    delete: operations['deleteUser'];
    /** Update an existing user */
    patch: operations['updateUser'];
  };
  '/users/invite': {
    /** Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account. */
    post: operations['invite'];
  };
  '/users/invite/accept': {
    /** Accepts and enables an invited user using a JWT invitation token. */
    post: operations['acceptInvite'];
  };
  '/users/me': {
    /** Retrieve the currently authenticated user. */
    get: operations['getMe'];
    /** Update the currently authenticated user. */
    patch: operations['updateMe'];
  };
  '/users/me/track/page': {
    /** Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used. */
    patch: operations['updateLastUsedPageMe'];
  };
  '/users/me/tfa/enable': {
    /** Enables two-factor authentication for the currently authenticated user. */
    post: operations['meTfaEnable'];
  };
  '/users/me/tfa/disable': {
    /** Disables two-factor authentication for the currently authenticated user. */
    post: operations['meTfaDisable'];
  };
  '/webhooks': {
    /** Get all webhooks. */
    get: operations['getWebhooks'];
    /** Create a new webhook. */
    post: operations['createWebhook'];
  };
  '/webhooks/{id}': {
    /** Retrieve a single webhook by unique identifier. */
    get: operations['getWebhook'];
    /** Delete an existing webhook */
    delete: operations['deleteWebhook'];
    /** Update an existing webhook */
    patch: operations['updateWebhook'];
  };
}

export interface components {
  schemas: {
    ItemsArticle: {
      id?: number;
      status?: string;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      title?: string;
      content?: string;
      featured_image?: (string | components['schemas']['Files']) | null;
      tags?: string[] | null;
      categories?: string;
    };
    ItemsArticleCategory: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      articles?: (
        | number
        | components['schemas']['ItemsArticleCategoryPivot']
      )[];
    };
    ItemsArticleCategoryPivot: {
      id?: number;
      article_id?: number | components['schemas']['ItemsArticle'];
      article_category_id?:
        | number
        | components['schemas']['ItemsArticleCategory'];
    };
    ItemsAudio: {
      id?: number;
      status?: string;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      title?: string;
      audio?: string | components['schemas']['Files'];
      description?: string | null;
      tags?: string[] | null;
      categories?: string;
    };
    ItemsAudioCategory: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      audios?: (number | components['schemas']['ItemsAudioCategoryPivot'])[];
    };
    ItemsAudioCategoryPivot: {
      id?: number;
      audio_id?: number | components['schemas']['ItemsAudio'];
      audio_category_id?: number | components['schemas']['ItemsAudioCategory'];
    };
    ItemsBook: {
      id?: number;
      status?: string;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      description?: string | null;
      book?: string | components['schemas']['Files'];
      author?: (number | components['schemas']['ItemsBookAuthor']) | null;
      tags?: string[] | null;
      categories?: string;
    };
    ItemsBookAuthor: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      photo?: (string | components['schemas']['Files']) | null;
      books?: (number | components['schemas']['ItemsBook'])[];
    };
    ItemsBookCategory: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      books?: (number | components['schemas']['ItemsBookCategoryPivot'])[];
    };
    ItemsBookCategoryPivot: {
      id?: number;
      book_id?: number | components['schemas']['ItemsBook'];
      book_category_id?: number | components['schemas']['ItemsBookCategory'];
    };
    ItemsComment: {
      id?: number;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      date_updated?: string | null;
      comment?: string;
      approved?: boolean | null;
      parent?: (number | components['schemas']['ItemsComment']) | null;
      entity?: (number | components['schemas']['ItemsCommentEntity'])[];
    };
    ItemsCommentEntity: {
      id?: number;
      comment_id?: number | components['schemas']['ItemsComment'];
      item?: (string | { [key: string]: any })[] | null;
      collection?: string | null;
    };
    ItemsDocument: {
      id?: number;
      status?: string;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      document?: string | components['schemas']['Files'];
      title?: string;
      description?: string | null;
      tags?: string[] | null;
      categories?: string;
    };
    ItemsDocumentCategory: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      documents?: (
        | number
        | components['schemas']['ItemsDocumentCategoryPivot']
      )[];
    };
    ItemsDocumentCategoryPivot: {
      id?: number;
      document_id?: number | components['schemas']['ItemsDocument'];
      document_category_id?:
        | number
        | components['schemas']['ItemsDocumentCategory'];
    };
    ItemsImage: {
      id?: number;
      status?: string;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      image?: string | components['schemas']['Files'];
      title?: string;
      description?: string | null;
      tags?: string[] | null;
      categories?: string;
    };
    ItemsImageCategory: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      images?: (number | components['schemas']['ItemsImageCategoryPivot'])[];
    };
    ItemsImageCategoryPivot: {
      id?: number;
      image_id?: number | components['schemas']['ItemsImage'];
      image_category_id?: number | components['schemas']['ItemsImageCategory'];
    };
    ItemsInstitute: {
      id?: number;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      phone_number?: string;
      email_address?: string;
      institute_name?: string | null;
    };
    ItemsMenu: {
      id?: number;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      title?: string;
      items?: string[] | null;
    };
    ItemsPage: {
      id?: number;
      status?: string;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      title?: string;
      content?: string;
      slug?: string;
    };
    ItemsQuestion: {
      id?: number;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      question?: string;
      answer?: string | null;
      question_type?: number | components['schemas']['ItemsQuestionType'];
      visible_on_website?: boolean;
      categories?: string;
    };
    ItemsQuestionCategory: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      visible_on_website?: boolean;
      questions?: (
        | number
        | components['schemas']['ItemsQuestionCategoryPivot']
      )[];
    };
    ItemsQuestionCategoryPivot: {
      id?: number;
      question_id?: number | components['schemas']['ItemsQuestion'];
      question_category_id?:
        | number
        | components['schemas']['ItemsQuestionCategory'];
    };
    ItemsQuestionType: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      visible_on_website?: boolean;
      questions?: (number | components['schemas']['ItemsQuestion'])[];
    };
    ItemsReaction: {
      id?: number;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      type?: number | components['schemas']['ItemsReactionType'];
      entity?: (number | components['schemas']['ItemsReactionEntity'])[];
    };
    ItemsReactionEntity: {
      id?: number;
      reaction_id?: number | components['schemas']['ItemsReaction'];
      item?: (string | { [key: string]: any })[];
      collection?: string;
    };
    ItemsReactionType: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      icon?: string;
      reactions?: (number | components['schemas']['ItemsReaction'])[];
    };
    ItemsSection: {
      id?: number;
      sort?: number | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      visible?: boolean;
      value?: string[] | null;
      page_section?: number | components['schemas']['ItemsThemePageSection'];
    };
    ItemsTheme: {
      id?: number;
      name?: string;
      pages?: (number | components['schemas']['ItemsThemePage'])[];
      websites?: (number | components['schemas']['ItemsWebsite'])[];
    };
    ItemsThemePage: {
      id?: number;
      sort?: number | null;
      name?: string;
      icon?: string | null;
      theme?: number | components['schemas']['ItemsTheme'];
      sections?: (number | components['schemas']['ItemsThemePageSection'])[];
    };
    ItemsThemePageSection: {
      id?: number;
      sort?: number | null;
      page?: number | components['schemas']['ItemsThemePage'];
      name?: string;
      fields?: string[] | null;
      icon?: string | null;
      sortable?: boolean;
      can_hide?: boolean;
      sections?: (number | components['schemas']['ItemsSection'])[];
    };
    ItemsVideo: {
      id?: number;
      status?: string;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      title?: string;
      video?: string | components['schemas']['Files'];
      description?: string | null;
      subtitle?: (string | components['schemas']['Files']) | null;
      tags?: string[] | null;
      categories?: string;
    };
    ItemsVideoCategory: {
      id?: number;
      sort?: number | null;
      user_created?: (string | components['schemas']['Users']) | null;
      date_created?: string | null;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      name?: string;
      videos?: (number | components['schemas']['ItemsVideoCategoryPivot'])[];
    };
    ItemsVideoCategoryPivot: {
      id?: number;
      video_id?: number | components['schemas']['ItemsVideo'];
      video_category_id?: number | components['schemas']['ItemsVideoCategory'];
    };
    ItemsWebsite: {
      id?: number;
      user_updated?: (string | components['schemas']['Users']) | null;
      date_updated?: string | null;
      title?: string;
      keywords?: string[] | null;
      description?: string;
      logo?: (string | components['schemas']['Files']) | null;
      theme?: (number | components['schemas']['ItemsTheme']) | null;
    };
    Activity: {
      /** Unique identifier for the object. */
      id?: number;
      /** Action that was performed. */
      action?: 'create' | 'update' | 'delete' | 'login';
      /** The user who performed this action. */
      user?: (string | components['schemas']['Users']) | null;
      /** When the action happened. */
      timestamp?: string;
      /** The IP address of the user at the time the action took place. */
      ip?: string;
      /** User agent string of the browser the user used when the action took place. */
      user_agent?: string;
      /** Collection identifier in which the item resides. */
      collection?: string | components['schemas']['Collections'];
      /** Unique identifier for the item the action applied to. This is always a string, even for integer primary keys. */
      item?: string;
      /** User comment. This will store the comments that show up in the right sidebar of the item edit page in the admin app. */
      comment?: string | null;
      revisions?: (number | components['schemas']['Revisions'])[];
    };
    Collections: {
      /** The collection key. */
      collection?: string;
      icon?: string | null;
      note?: string | null;
      display_template?: string | null;
      hidden?: boolean;
      singleton?: boolean;
      translations?: string[] | null;
      archive_field?: string | null;
      archive_app_filter?: boolean;
      archive_value?: string | null;
      unarchive_value?: string | null;
      sort_field?: string | null;
      accountability?: string | null;
      color?: string | null;
      item_duplication_fields?: string[] | null;
      sort?: number | null;
      group?: (string | components['schemas']['Collections']) | null;
      collapse?: string;
      collection_divider?: string;
      archive_divider?: string;
      sort_divider?: string;
      accountability_divider?: string;
      duplication_divider?: string;
    };
    Fields: {
      id?: number;
      /** Unique name of the collection this field is in. */
      collection?: string;
      /** Unique name of the field. Field name is unique within the collection. */
      field?: string;
      special?: string[] | null;
      interface?: string | null;
      options?: string[] | null;
      display?: string | null;
      display_options?: string[] | null;
      readonly?: boolean;
      hidden?: boolean;
      sort?: number | null;
      width?: string | null;
      translations?: string[] | null;
      note?: string | null;
      conditions?: string[] | null;
      required?: boolean | null;
      group?: (number | components['schemas']['Fields']) | null;
    };
    Files: {
      /** Unique identifier for the file. */
      id?: string;
      /** Where the file is stored. Either `local` for the local filesystem or the name of the storage adapter (for example `s3`). */
      storage?: string;
      /** Name of the file on disk. By default, Directus uses a random hash for the filename. */
      filename_disk?: string;
      /** How you want to the file to be named when it's being downloaded. */
      filename_download?: string;
      /** Title for the file. Is extracted from the filename on upload, but can be edited by the user. */
      title?: string;
      /** MIME type of the file. */
      type?: string;
      /** Virtual folder where this file resides in. */
      folder?: (string | components['schemas']['Folders']) | null;
      /** Who uploaded the file. */
      uploaded_by?: string | components['schemas']['Users'];
      /** When the file was uploaded. */
      uploaded_on?: string;
      modified_by?: (string | components['schemas']['Users']) | null;
      modified_on?: string;
      /** Character set of the file. */
      charset?: string | null;
      /** Size of the file in bytes. */
      filesize?: number;
      /** Width of the file in pixels. Only applies to images. */
      width?: number | null;
      /** Height of the file in pixels. Only applies to images. */
      height?: number | null;
      /** Duration of the file in seconds. Only applies to audio and video. */
      duration?: number | null;
      /** Where the file was embedded from. */
      embed?: string | null;
      /** Description for the file. */
      description?: string | null;
      /** Where the file was created. Is automatically populated based on EXIF data for images. */
      location?: string | null;
      /** Tags for the file. Is automatically populated based on EXIF data for images. */
      tags?: string[] | null;
      /** IPTC, EXIF, and ICC metadata extracted from file */
      metadata?: { [key: string]: any } | null;
      storage_divider?: string;
    };
    Folders: {
      /** Unique identifier for the folder. */
      id?: string;
      /** Name of the folder. */
      name?: string;
      /** Unique identifier of the parent folder. This allows for nested folders. */
      parent?: (string | components['schemas']['Folders']) | null;
    };
    Permissions: {
      /** Unique identifier for the permission. */
      id?: number;
      /** Unique identifier of the role this permission applies to. */
      role?: string | null;
      /** What collection this permission applies to. */
      collection?: string;
      /** What action this permission applies to. */
      action?: 'create' | 'read' | 'update' | 'delete';
      /** JSON structure containing the permissions checks for this permission. */
      permissions?: { [key: string]: any } | null;
      /** JSON structure containing the validation checks for this permission. */
      validation?: { [key: string]: any } | null;
      /** JSON structure containing the preset value for created/updated items. */
      presets?: { [key: string]: any } | null;
      /** CSV of fields that the user is allowed to interact with. */
      fields?: string[] | null;
    };
    Presets: {
      /** Unique identifier for this single collection preset. */
      id?: number;
      /** Name for the bookmark. If this is set, the preset will be considered a bookmark. */
      bookmark?: string | null;
      /** The unique identifier of the user to whom this collection preset applies. */
      user?: (string | components['schemas']['Users']) | null;
      /** The unique identifier of a role in the platform. If `user` is null, this will be used to apply the collection preset or bookmark for all users in the role. */
      role?: (string | components['schemas']['Roles']) | null;
      /** What collection this collection preset is used for. */
      collection?: string | components['schemas']['Collections'];
      /** Search query. */
      search?: string | null;
      /** Key of the layout that is used. */
      layout?: string;
      /** Layout query that's saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters. */
      layout_query?: { [key: string]: any } | null;
      /** Options of the views. The properties in here are controlled by the layout. */
      layout_options?: { [key: string]: any } | null;
      refresh_interval?: number | null;
      filter?: string[] | null;
    };
    Relations: {
      /** Unique identifier for the relation. */
      id?: number;
      /** Collection that has the field that holds the foreign key. */
      many_collection?: string;
      /** Foreign key. Field that holds the primary key of the related collection. */
      many_field?: string;
      /** Collection on the _one_ side of the relationship. */
      one_collection?: string;
      /** Alias column that serves as the _one_ side of the relationship. */
      one_field?: string | null;
      one_collection_field?: string | null;
      one_allowed_collections?: string[] | null;
      /** Field on the junction table that holds the many field of the related relation. */
      junction_field?: string | null;
      sort_field?: string | null;
      one_deselect_action?: string;
    };
    Revisions: {
      /** Unique identifier for the revision. */
      id?: number;
      /** Unique identifier for the activity record. */
      activity?: number | components['schemas']['Activity'];
      /** Collection of the updated item. */
      collection?: string | components['schemas']['Collections'];
      /** Primary key of updated item. */
      item?: string;
      /** Copy of item state at time of update. */
      data?: { [key: string]: any } | null;
      /** Changes between the previous and the current revision. */
      delta?: { [key: string]: any };
      /** If the current item was updated relationally, this is the id of the parent revision record */
      parent?: number | null;
    };
    Roles: {
      /** Unique identifier for the role. */
      id?: string;
      /** Name of the role. */
      name?: string;
      /** The role's icon. */
      icon?: string;
      /** Description of the role. */
      description?: string | null;
      /** Array of IP addresses that are allowed to connect to the API as a user of this role. */
      ip_access?: string[];
      /** Whether or not this role enforces the use of 2FA. */
      enforce_tfa?: boolean;
      /** Admin role. If true, skips all permission checks. */
      admin_access?: boolean;
      /** The users in the role are allowed to use the app. */
      app_access?: boolean;
      users?: (string | components['schemas']['Users'])[];
    };
    Settings: {
      /** Unique identifier for the setting. */
      id?: number;
      /** The name of the project. */
      project_name?: string;
      /** The url of the project. */
      project_url?: string | null;
      /** The brand color of the project. */
      project_color?: string | null;
      /** The logo of the project. */
      project_logo?: string | null;
      /** The foreground of the project. */
      public_foreground?: string | null;
      /** The background of the project. */
      public_background?: string | null;
      /** Note rendered on the public pages of the app. */
      public_note?: string | null;
      /** Allowed authentication login attempts before the user's status is set to blocked. */
      auth_login_attempts?: number;
      /** Authentication password policy. */
      auth_password_policy?: string | null;
      /** What transformations are allowed in the assets endpoint. */
      storage_asset_transform?: ('all' | 'none' | 'presets') | null;
      /** Array of allowed */
      storage_asset_presets?:
        | {
            /** Key for the asset. Used in the assets endpoint. */
            key?: string;
            /** Whether to crop the thumbnail to match the size, or maintain the aspect ratio. */
            fit?: 'cover' | 'contain' | 'inside' | 'outside';
            /** Width of the thumbnail. */
            width?: number;
            /** Height of the thumbnail. */
            height?: number;
            /** No image upscale */
            withoutEnlargement?: boolean;
            /** Quality of the compression used. */
            quality?: number;
            /** Reformat output image */
            format?: '' | 'jpeg' | 'png' | 'webp' | 'tiff';
            /** Additional transformations to apply */
            transforms?:
              | {
                  /** The Sharp method name */
                  method?: string;
                  /** A list of arguments to pass to the Sharp method */
                  arguments?:
                    | {
                        /** A JSON representation of the argument value */
                        argument?: string;
                      }[]
                    | null;
                }[]
              | null;
          }[]
        | null;
      custom_css?: string | null;
      /** Default folder to place files */
      storage_default_folder?: string;
      basemaps?: string[] | null;
      mapbox_key?: string | null;
      module_bar?: string[] | null;
      branding_divider?: string;
      modules_divider?: string;
      security_divider?: string;
      files_divider?: string;
      map_divider?: string;
    };
    Users: {
      /** Unique identifier for the user. */
      id?: string;
      /** First name of the user. */
      first_name?: string;
      /** Last name of the user. */
      last_name?: string;
      /** Unique email address for the user. */
      email?: string;
      /** Password of the user. */
      password?: string;
      /** The user's location. */
      location?: string | null;
      /** The user's title. */
      title?: string | null;
      /** The user's description. */
      description?: string | null;
      /** The user's tags. */
      tags?: string[] | null;
      /** The user's avatar. */
      avatar?: (string | components['schemas']['Files']) | null;
      /** The user's language used in Directus. */
      language?: string;
      /** What theme the user is using. */
      theme?: 'light' | 'dark' | 'auto';
      /** The 2FA secret string that's used to generate one time passwords. */
      tfa_secret?: string | null;
      /** Status of the user. */
      status?: 'active' | 'invited' | 'draft' | 'suspended' | 'deleted';
      /** Unique identifier of the role of this user. */
      role?: string | components['schemas']['Roles'];
      /** Static token for the user. */
      token?: string | null;
      last_access?: string | null;
      /** Last page that the user was on. */
      last_page?: string | null;
      provider?: string;
      external_identifier?: string | null;
      auth_data?: string[] | null;
      preferences_divider?: string;
      admin_divider?: string;
    };
    Webhooks: {
      /** The index of the webhook. */
      id?: number;
      /** The name of the webhook. */
      name?: string;
      /** Method used in the webhook. */
      method?: string;
      /** The url of the webhook. */
      url?: string | null;
      /** The status of the webhook. */
      status?: string;
      /** If yes, send the content of what was done */
      data?: boolean;
      /** The actions that triggers this webhook. */
      actions?: string[] | null;
      collections?: string[];
      headers?: string[] | null;
      triggers_divider?: string;
    };
  };
  responses: {
    /** Error: Not found. */
    NotFoundError: {
      content: {
        'application/json': {
          error?: {
            code?: number;
            message?: string;
          };
        };
      };
    };
    /** Error: Unauthorized request */
    UnauthorizedError: {
      content: {
        'application/json': {
          error?: {
            code?: number;
            message?: string;
          };
        };
      };
    };
  };
  parameters: {
    /** Index */
    Id: number;
    /** Unique identifier for the object. */
    UUId: string;
    /** Collection of which you want to retrieve the items from. */
    Collection: string;
    /** Filter by items that contain the given search query in one of their fields. */
    Search: string;
    /** Cursor for use in pagination. Often used in combination with limit. */
    Page: number;
    /** How many items to skip when fetching data. */
    Offset: number;
    /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
    Sort: string[];
    /** What metadata to return in the response. */
    Meta: string;
    /** A limit on the number of objects that are returned. */
    Limit: number;
    /** Select items in collection by given conditions. */
    Filter: string[];
    /** Control what fields are being returned in the object. */
    Fields: string[];
    /** Controls if the API sets a cookie or returns a JWT on successful login. */
    Mode: 'jwt' | 'cookie';
  };
}

export interface operations {
  /** Image typed files can be dynamically resized and transformed to fit any need. */
  getAsset: {
    parameters: {
      path: {
        /** The id of the file. */
        id: string;
      };
      query: {
        /** The key of the asset size configured in settings. */
        key?: string;
        /** A JSON array of image transformations */
        transforms?: string;
        /** Download the asset to your computer */
        download?: boolean;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'text/plain': string;
        };
      };
      404: components['responses']['NotFoundError'];
    };
  };
  /** Retrieve a Temporary Access Token */
  login: {
    responses: {
      /** Successful authentification */
      200: {
        content: {
          'application/json': {
            data?: {
              access_token?: string;
              expires?: number;
              refresh_token?: string;
            };
          };
        };
      };
    };
    requestBody: {
      content: {
        'application/json': {
          /** Email address of the user you're retrieving the access token for. */
          email: string;
          /** Password of the user. */
          password: string;
          /** Choose between retrieving the token as a string, or setting it as a cookie. */
          mode?: 'json' | 'cookie';
          /** If 2FA is enabled, you need to pass the one time password. */
          otp?: string;
        };
      };
    };
  };
  /** Refresh a Temporary Access Token. */
  refresh: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: {
              access_token?: string;
              expires?: number;
              refresh_token?: string;
            };
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** JWT access token you want to refresh. This token can't be expired. */
          refresh_token?: string;
        };
      };
    };
  };
  /** Log Out */
  logout: {
    responses: {
      /** Request successful */
      200: unknown;
    };
    requestBody: {
      content: {
        'application/json': {
          /** JWT access token you want to logout. */
          refresh_token?: string;
        };
      };
    };
  };
  /** Request a reset password email to be send. */
  passwordRequest: {
    responses: {
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Email address of the user you're requesting a reset for. */
          email: string;
        };
      };
    };
  };
  /** The request a password reset endpoint sends an email with a link to the admin app which in turn uses this endpoint to allow the user to reset their password. */
  passwordReset: {
    responses: {
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** One-time use JWT token that is used to verify the user. */
          token: string;
          /** New password for the user. */
          password: string;
        };
      };
    };
  };
  /** List configured OAuth providers. */
  oauth: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            public?: boolean;
            data?: string[];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Start OAuth flow using the specified provider */
  oauthProvider: {
    parameters: {
      path: {
        /** Key of the activated OAuth provider. */
        provider: string;
      };
      query: {
        /** Where to redirect on successful login.<br/>If set the authentication details are set inside cookies otherwise a JSON is returned. */
        redirect?: string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            public?: boolean;
            data?: {
              token?: string;
            };
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** List all installed custom interfaces. */
  getInterfaces: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: { [key: string]: any }[];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** List all installed custom layouts. */
  getLayouts: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: { [key: string]: any }[];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** List all installed custom displays. */
  getDisplays: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: { [key: string]: any }[];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** List all installed custom modules. */
  getModules: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: { [key: string]: any }[];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Perform a system status check and return the options. */
  serverInfo: {
    parameters: {
      query: {
        /** The first time you create a project, the provided token will be saved and required for subsequent project installs. It can also be found and configured in `/config/__api.json` on your server. */
        super_admin_token: number;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: { [key: string]: any };
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Ping, pong. Ping.. pong. */
  ping: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/text': string;
        };
      };
    };
  };
  /** Returns a random string of given length. */
  random: {
    parameters: {
      query: {
        /** Length of the random string. */
        length?: number;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: string;
          };
        };
      };
    };
  };
  /** Re-sort items in collection based on start and to value of item */
  sort: {
    parameters: {
      path: {
        /** Collection identifier */
        collection: string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
    };
    requestBody: {
      content: {
        'application/json': {
          /** Primary key of item to move */
          item?: number;
          /** Primary key of item where to move the current item to */
          to?: number;
        };
      };
    };
  };
  /** List the article items. */
  readItemsArticle: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticle'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new article item. */
  createItemsArticle: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticle'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsArticle'][]
          | components['schemas']['ItemsArticle'];
      };
    };
  };
  /** Retrieve a single article item by unique identifier. */
  readSingleItemsArticle: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticle'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing article item. */
  deleteSingleItemsArticle: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing article item. */
  updateSingleItemsArticle: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticle'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsArticle'];
      };
    };
  };
  /** List the article_category items. */
  readItemsArticleCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new article_category item. */
  createItemsArticleCategory: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsArticleCategory'][]
          | components['schemas']['ItemsArticleCategory'];
      };
    };
  };
  /** Retrieve a single article_category item by unique identifier. */
  readSingleItemsArticleCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing article_category item. */
  deleteSingleItemsArticleCategory: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing article_category item. */
  updateSingleItemsArticleCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsArticleCategory'];
      };
    };
  };
  /** List the article_category_pivot items. */
  readItemsArticleCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new article_category_pivot item. */
  createItemsArticleCategoryPivot: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsArticleCategoryPivot'][]
          | components['schemas']['ItemsArticleCategoryPivot'];
      };
    };
  };
  /** Retrieve a single article_category_pivot item by unique identifier. */
  readSingleItemsArticleCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing article_category_pivot item. */
  deleteSingleItemsArticleCategoryPivot: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing article_category_pivot item. */
  updateSingleItemsArticleCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsArticleCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsArticleCategoryPivot'];
      };
    };
  };
  /** List the audio items. */
  readItemsAudio: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudio'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new audio item. */
  createItemsAudio: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudio'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsAudio'][]
          | components['schemas']['ItemsAudio'];
      };
    };
  };
  /** Retrieve a single audio item by unique identifier. */
  readSingleItemsAudio: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudio'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing audio item. */
  deleteSingleItemsAudio: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing audio item. */
  updateSingleItemsAudio: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudio'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsAudio'];
      };
    };
  };
  /** List the audio_category items. */
  readItemsAudioCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new audio_category item. */
  createItemsAudioCategory: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsAudioCategory'][]
          | components['schemas']['ItemsAudioCategory'];
      };
    };
  };
  /** Retrieve a single audio_category item by unique identifier. */
  readSingleItemsAudioCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing audio_category item. */
  deleteSingleItemsAudioCategory: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing audio_category item. */
  updateSingleItemsAudioCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsAudioCategory'];
      };
    };
  };
  /** List the audio_category_pivot items. */
  readItemsAudioCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new audio_category_pivot item. */
  createItemsAudioCategoryPivot: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsAudioCategoryPivot'][]
          | components['schemas']['ItemsAudioCategoryPivot'];
      };
    };
  };
  /** Retrieve a single audio_category_pivot item by unique identifier. */
  readSingleItemsAudioCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing audio_category_pivot item. */
  deleteSingleItemsAudioCategoryPivot: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing audio_category_pivot item. */
  updateSingleItemsAudioCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsAudioCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsAudioCategoryPivot'];
      };
    };
  };
  /** List the book items. */
  readItemsBook: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBook'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new book item. */
  createItemsBook: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBook'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsBook'][]
          | components['schemas']['ItemsBook'];
      };
    };
  };
  /** Retrieve a single book item by unique identifier. */
  readSingleItemsBook: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBook'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing book item. */
  deleteSingleItemsBook: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing book item. */
  updateSingleItemsBook: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBook'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsBook'];
      };
    };
  };
  /** List the book_author items. */
  readItemsBookAuthor: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookAuthor'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new book_author item. */
  createItemsBookAuthor: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookAuthor'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsBookAuthor'][]
          | components['schemas']['ItemsBookAuthor'];
      };
    };
  };
  /** Retrieve a single book_author item by unique identifier. */
  readSingleItemsBookAuthor: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookAuthor'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing book_author item. */
  deleteSingleItemsBookAuthor: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing book_author item. */
  updateSingleItemsBookAuthor: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookAuthor'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsBookAuthor'];
      };
    };
  };
  /** List the book_category items. */
  readItemsBookCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new book_category item. */
  createItemsBookCategory: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsBookCategory'][]
          | components['schemas']['ItemsBookCategory'];
      };
    };
  };
  /** Retrieve a single book_category item by unique identifier. */
  readSingleItemsBookCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing book_category item. */
  deleteSingleItemsBookCategory: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing book_category item. */
  updateSingleItemsBookCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsBookCategory'];
      };
    };
  };
  /** List the book_category_pivot items. */
  readItemsBookCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new book_category_pivot item. */
  createItemsBookCategoryPivot: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsBookCategoryPivot'][]
          | components['schemas']['ItemsBookCategoryPivot'];
      };
    };
  };
  /** Retrieve a single book_category_pivot item by unique identifier. */
  readSingleItemsBookCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing book_category_pivot item. */
  deleteSingleItemsBookCategoryPivot: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing book_category_pivot item. */
  updateSingleItemsBookCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsBookCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsBookCategoryPivot'];
      };
    };
  };
  /** List the comment items. */
  readItemsComment: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsComment'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new comment item. */
  createItemsComment: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsComment'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsComment'][]
          | components['schemas']['ItemsComment'];
      };
    };
  };
  /** Retrieve a single comment item by unique identifier. */
  readSingleItemsComment: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsComment'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing comment item. */
  deleteSingleItemsComment: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing comment item. */
  updateSingleItemsComment: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsComment'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsComment'];
      };
    };
  };
  /** List the comment_entity items. */
  readItemsCommentEntity: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsCommentEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new comment_entity item. */
  createItemsCommentEntity: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsCommentEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsCommentEntity'][]
          | components['schemas']['ItemsCommentEntity'];
      };
    };
  };
  /** Retrieve a single comment_entity item by unique identifier. */
  readSingleItemsCommentEntity: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsCommentEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing comment_entity item. */
  deleteSingleItemsCommentEntity: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing comment_entity item. */
  updateSingleItemsCommentEntity: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsCommentEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsCommentEntity'];
      };
    };
  };
  /** List the document items. */
  readItemsDocument: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocument'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new document item. */
  createItemsDocument: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocument'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsDocument'][]
          | components['schemas']['ItemsDocument'];
      };
    };
  };
  /** Retrieve a single document item by unique identifier. */
  readSingleItemsDocument: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocument'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing document item. */
  deleteSingleItemsDocument: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing document item. */
  updateSingleItemsDocument: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocument'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsDocument'];
      };
    };
  };
  /** List the document_category items. */
  readItemsDocumentCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new document_category item. */
  createItemsDocumentCategory: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsDocumentCategory'][]
          | components['schemas']['ItemsDocumentCategory'];
      };
    };
  };
  /** Retrieve a single document_category item by unique identifier. */
  readSingleItemsDocumentCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing document_category item. */
  deleteSingleItemsDocumentCategory: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing document_category item. */
  updateSingleItemsDocumentCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsDocumentCategory'];
      };
    };
  };
  /** List the document_category_pivot items. */
  readItemsDocumentCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new document_category_pivot item. */
  createItemsDocumentCategoryPivot: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsDocumentCategoryPivot'][]
          | components['schemas']['ItemsDocumentCategoryPivot'];
      };
    };
  };
  /** Retrieve a single document_category_pivot item by unique identifier. */
  readSingleItemsDocumentCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing document_category_pivot item. */
  deleteSingleItemsDocumentCategoryPivot: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing document_category_pivot item. */
  updateSingleItemsDocumentCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsDocumentCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsDocumentCategoryPivot'];
      };
    };
  };
  /** List the image items. */
  readItemsImage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new image item. */
  createItemsImage: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsImage'][]
          | components['schemas']['ItemsImage'];
      };
    };
  };
  /** Retrieve a single image item by unique identifier. */
  readSingleItemsImage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing image item. */
  deleteSingleItemsImage: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing image item. */
  updateSingleItemsImage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsImage'];
      };
    };
  };
  /** List the image_category items. */
  readItemsImageCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new image_category item. */
  createItemsImageCategory: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsImageCategory'][]
          | components['schemas']['ItemsImageCategory'];
      };
    };
  };
  /** Retrieve a single image_category item by unique identifier. */
  readSingleItemsImageCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing image_category item. */
  deleteSingleItemsImageCategory: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing image_category item. */
  updateSingleItemsImageCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsImageCategory'];
      };
    };
  };
  /** List the image_category_pivot items. */
  readItemsImageCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new image_category_pivot item. */
  createItemsImageCategoryPivot: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsImageCategoryPivot'][]
          | components['schemas']['ItemsImageCategoryPivot'];
      };
    };
  };
  /** Retrieve a single image_category_pivot item by unique identifier. */
  readSingleItemsImageCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing image_category_pivot item. */
  deleteSingleItemsImageCategoryPivot: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing image_category_pivot item. */
  updateSingleItemsImageCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsImageCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsImageCategoryPivot'];
      };
    };
  };
  /** List the institute items. */
  readItemsInstitute: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsInstitute'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new institute item. */
  createItemsInstitute: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsInstitute'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsInstitute'][]
          | components['schemas']['ItemsInstitute'];
      };
    };
  };
  /** Retrieve a single institute item by unique identifier. */
  readSingleItemsInstitute: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsInstitute'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing institute item. */
  deleteSingleItemsInstitute: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing institute item. */
  updateSingleItemsInstitute: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsInstitute'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsInstitute'];
      };
    };
  };
  /** List the menu items. */
  readItemsMenu: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsMenu'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new menu item. */
  createItemsMenu: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsMenu'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsMenu'][]
          | components['schemas']['ItemsMenu'];
      };
    };
  };
  /** Retrieve a single menu item by unique identifier. */
  readSingleItemsMenu: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsMenu'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing menu item. */
  deleteSingleItemsMenu: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing menu item. */
  updateSingleItemsMenu: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsMenu'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsMenu'];
      };
    };
  };
  /** List the page items. */
  readItemsPage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsPage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new page item. */
  createItemsPage: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsPage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsPage'][]
          | components['schemas']['ItemsPage'];
      };
    };
  };
  /** Retrieve a single page item by unique identifier. */
  readSingleItemsPage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsPage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing page item. */
  deleteSingleItemsPage: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing page item. */
  updateSingleItemsPage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsPage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsPage'];
      };
    };
  };
  /** List the question items. */
  readItemsQuestion: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestion'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new question item. */
  createItemsQuestion: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestion'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsQuestion'][]
          | components['schemas']['ItemsQuestion'];
      };
    };
  };
  /** Retrieve a single question item by unique identifier. */
  readSingleItemsQuestion: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestion'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing question item. */
  deleteSingleItemsQuestion: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing question item. */
  updateSingleItemsQuestion: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestion'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsQuestion'];
      };
    };
  };
  /** List the question_category items. */
  readItemsQuestionCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new question_category item. */
  createItemsQuestionCategory: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsQuestionCategory'][]
          | components['schemas']['ItemsQuestionCategory'];
      };
    };
  };
  /** Retrieve a single question_category item by unique identifier. */
  readSingleItemsQuestionCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing question_category item. */
  deleteSingleItemsQuestionCategory: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing question_category item. */
  updateSingleItemsQuestionCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsQuestionCategory'];
      };
    };
  };
  /** List the question_category_pivot items. */
  readItemsQuestionCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new question_category_pivot item. */
  createItemsQuestionCategoryPivot: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsQuestionCategoryPivot'][]
          | components['schemas']['ItemsQuestionCategoryPivot'];
      };
    };
  };
  /** Retrieve a single question_category_pivot item by unique identifier. */
  readSingleItemsQuestionCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing question_category_pivot item. */
  deleteSingleItemsQuestionCategoryPivot: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing question_category_pivot item. */
  updateSingleItemsQuestionCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsQuestionCategoryPivot'];
      };
    };
  };
  /** List the question_type items. */
  readItemsQuestionType: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new question_type item. */
  createItemsQuestionType: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsQuestionType'][]
          | components['schemas']['ItemsQuestionType'];
      };
    };
  };
  /** Retrieve a single question_type item by unique identifier. */
  readSingleItemsQuestionType: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing question_type item. */
  deleteSingleItemsQuestionType: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing question_type item. */
  updateSingleItemsQuestionType: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsQuestionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsQuestionType'];
      };
    };
  };
  /** List the reaction items. */
  readItemsReaction: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReaction'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new reaction item. */
  createItemsReaction: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReaction'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsReaction'][]
          | components['schemas']['ItemsReaction'];
      };
    };
  };
  /** Retrieve a single reaction item by unique identifier. */
  readSingleItemsReaction: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReaction'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing reaction item. */
  deleteSingleItemsReaction: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing reaction item. */
  updateSingleItemsReaction: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReaction'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsReaction'];
      };
    };
  };
  /** List the reaction_entity items. */
  readItemsReactionEntity: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new reaction_entity item. */
  createItemsReactionEntity: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsReactionEntity'][]
          | components['schemas']['ItemsReactionEntity'];
      };
    };
  };
  /** Retrieve a single reaction_entity item by unique identifier. */
  readSingleItemsReactionEntity: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing reaction_entity item. */
  deleteSingleItemsReactionEntity: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing reaction_entity item. */
  updateSingleItemsReactionEntity: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionEntity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsReactionEntity'];
      };
    };
  };
  /** List the reaction_type items. */
  readItemsReactionType: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new reaction_type item. */
  createItemsReactionType: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsReactionType'][]
          | components['schemas']['ItemsReactionType'];
      };
    };
  };
  /** Retrieve a single reaction_type item by unique identifier. */
  readSingleItemsReactionType: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing reaction_type item. */
  deleteSingleItemsReactionType: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing reaction_type item. */
  updateSingleItemsReactionType: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsReactionType'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsReactionType'];
      };
    };
  };
  /** List the section items. */
  readItemsSection: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new section item. */
  createItemsSection: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsSection'][]
          | components['schemas']['ItemsSection'];
      };
    };
  };
  /** Retrieve a single section item by unique identifier. */
  readSingleItemsSection: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing section item. */
  deleteSingleItemsSection: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing section item. */
  updateSingleItemsSection: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsSection'];
      };
    };
  };
  /** List the theme items. */
  readItemsTheme: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsTheme'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new theme item. */
  createItemsTheme: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsTheme'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsTheme'][]
          | components['schemas']['ItemsTheme'];
      };
    };
  };
  /** Retrieve a single theme item by unique identifier. */
  readSingleItemsTheme: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsTheme'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing theme item. */
  deleteSingleItemsTheme: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing theme item. */
  updateSingleItemsTheme: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsTheme'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsTheme'];
      };
    };
  };
  /** List the theme_page items. */
  readItemsThemePage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new theme_page item. */
  createItemsThemePage: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsThemePage'][]
          | components['schemas']['ItemsThemePage'];
      };
    };
  };
  /** Retrieve a single theme_page item by unique identifier. */
  readSingleItemsThemePage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing theme_page item. */
  deleteSingleItemsThemePage: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing theme_page item. */
  updateSingleItemsThemePage: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePage'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsThemePage'];
      };
    };
  };
  /** List the theme_page_section items. */
  readItemsThemePageSection: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePageSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new theme_page_section item. */
  createItemsThemePageSection: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePageSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsThemePageSection'][]
          | components['schemas']['ItemsThemePageSection'];
      };
    };
  };
  /** Retrieve a single theme_page_section item by unique identifier. */
  readSingleItemsThemePageSection: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePageSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing theme_page_section item. */
  deleteSingleItemsThemePageSection: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing theme_page_section item. */
  updateSingleItemsThemePageSection: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsThemePageSection'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsThemePageSection'];
      };
    };
  };
  /** List the video items. */
  readItemsVideo: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideo'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new video item. */
  createItemsVideo: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideo'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsVideo'][]
          | components['schemas']['ItemsVideo'];
      };
    };
  };
  /** Retrieve a single video item by unique identifier. */
  readSingleItemsVideo: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideo'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing video item. */
  deleteSingleItemsVideo: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing video item. */
  updateSingleItemsVideo: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideo'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsVideo'];
      };
    };
  };
  /** List the video_category items. */
  readItemsVideoCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new video_category item. */
  createItemsVideoCategory: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsVideoCategory'][]
          | components['schemas']['ItemsVideoCategory'];
      };
    };
  };
  /** Retrieve a single video_category item by unique identifier. */
  readSingleItemsVideoCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing video_category item. */
  deleteSingleItemsVideoCategory: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing video_category item. */
  updateSingleItemsVideoCategory: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategory'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsVideoCategory'];
      };
    };
  };
  /** List the video_category_pivot items. */
  readItemsVideoCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new video_category_pivot item. */
  createItemsVideoCategoryPivot: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsVideoCategoryPivot'][]
          | components['schemas']['ItemsVideoCategoryPivot'];
      };
    };
  };
  /** Retrieve a single video_category_pivot item by unique identifier. */
  readSingleItemsVideoCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing video_category_pivot item. */
  deleteSingleItemsVideoCategoryPivot: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing video_category_pivot item. */
  updateSingleItemsVideoCategoryPivot: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsVideoCategoryPivot'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsVideoCategoryPivot'];
      };
    };
  };
  /** List the website items. */
  readItemsWebsite: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsWebsite'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new website item. */
  createItemsWebsite: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsWebsite'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['ItemsWebsite'][]
          | components['schemas']['ItemsWebsite'];
      };
    };
  };
  /** Retrieve a single website item by unique identifier. */
  readSingleItemsWebsite: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsWebsite'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing website item. */
  deleteSingleItemsWebsite: {
    parameters: {
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing website item. */
  updateSingleItemsWebsite: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
      path: {
        /** Index of the item. */
        id: number | string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['ItemsWebsite'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ItemsWebsite'];
      };
    };
  };
  /** Returns a list of activity actions. */
  getActivities: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Activity'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Creates a new comment. */
  createComment: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Activity'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          collection: string;
          item: number;
          comment: string;
        };
      };
    };
  };
  /** Retrieves the details of an existing activity action. Provide the primary key of the activity action and Directus will return the corresponding information. */
  getActivity: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Activity'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing comment. Deleted comments can not be retrieved. */
  deleteComment: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
    };
    responses: {
      /** Deleted succsessfully */
      203: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update the content of an existing comment. */
  updateComment: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Activity'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          comment?: string;
        };
      };
    };
  };
  /** Returns a list of the collections available in the project. */
  getCollections: {
    parameters: {
      query: {
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Collections'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new collection in Directus. */
  createCollection: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Collections'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Unique name of the collection. */
          collection: string;
          /** The fields contained in this collection. See the fields reference for more information. Each individual field requires field, type, and interface to be provided. */
          fields: { [key: string]: any }[];
          /** Name of a Google Material Design Icon that's assigned to this collection. */
          icon?: string | null;
          /** A note describing the collection. */
          note?: string | null;
          /** Text representation of how items from this collection are shown across the system. */
          display_template?: string | null;
          /** Whether or not the collection is hidden from the navigation in the admin app. */
          hidden?: boolean;
          /** Whether or not the collection is treated as a single object. */
          singleton?: boolean;
          /** Key value pairs of how to show this collection's name in different languages in the admin app. */
          translation?: string | null;
          /** What field holds the archive value. */
          archive_field?: string | null;
          /** What value to use for "archived" items. */
          archive_app_filter?: string | null;
          /** What value to use to "unarchive" items. */
          archive_value?: string | null;
          /** Whether or not to show the "archived" filter. */
          unarchive_value?: string | null;
          /** The sort field in the collection. */
          sort_field?: string | null;
        };
      };
    };
  };
  /** Retrieves the details of a single collection. */
  getCollection: {
    parameters: {
      path: {
        /** Unique identifier of the collection. */
        id: string;
      };
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Collections'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing collection. Warning: This will delete the whole collection, including the items within. Proceed with caution. */
  deleteCollection: {
    parameters: {
      path: {
        /** Unique identifier of the collection. */
        id: string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing collection. */
  updateCollection: {
    parameters: {
      path: {
        /** Unique identifier of the collection. */
        id: string;
      };
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Collections'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Metadata of the collection. */
          meta?: {
            /** Name of a Google Material Design Icon that's assigned to this collection. */
            icon?: string | null;
            /** Choose the color for the icon assigned to this collection. */
            color?: string | null;
            /** A note describing the collection. */
            note?: string | null;
            /** Text representation of how items from this collection are shown across the system. */
            display_template?: string | null;
            /** Whether or not the collection is hidden from the navigation in the admin app. */
            hidden?: boolean;
            /** Whether or not the collection is treated as a single object. */
            singleton?: boolean;
            /** Key value pairs of how to show this collection's name in different languages in the admin app. */
            translation?: string | null;
            /** What field holds the archive value. */
            archive_field?: string | null;
            /** What value to use for "archived" items. */
            archive_app_filter?: string | null;
            /** What value to use to "unarchive" items. */
            archive_value?: string | null;
            /** Whether or not to show the "archived" filter. */
            unarchive_value?: string | null;
            /** The sort field in the collection. */
            sort_field?: string | null;
          };
        };
      };
    };
  };
  /** Returns a list of the fields available in the project. */
  getFields: {
    parameters: {
      query: {
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Fields'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Returns a list of the fields available in the given collection. */
  getCollectionFields: {
    parameters: {
      path: {
        /** Unique identifier of the collection the item resides in. */
        collection: string;
      };
      query: {
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Fields'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new field in a given collection. */
  createField: {
    parameters: {
      path: {
        /** Unique identifier of the collection the item resides in. */
        collection: string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Fields'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Unique name of the field. Field name is unique within the collection. */
          field: string;
          /** Directus specific data type. Used to cast values in the API. */
          type: string;
          /** The schema info. */
          schema?: {
            /** The name of the field. */
            name?: string;
            /** The collection of the field. */
            table?: string;
            /** The type of the field. */
            type?: string;
            /** The default value of the field. */
            default_value?: string | null;
            /** The max length of the field. */
            max_length?: number | null;
            /** If the field is nullable. */
            is_nullable?: boolean;
            /** If the field is primary key. */
            is_primary_key?: boolean;
            /** If the field has auto increment. */
            has_auto_increment?: boolean;
            /** Related column from the foreign key constraint. */
            foreign_key_column?: string | null;
            /** Related table from the foreign key constraint. */
            foreign_key_table?: string | null;
            /** Comment as saved in the database. */
            comment?: string | null;
            /** Database schema (pg only). */
            schema?: string;
            /** Related schema from the foreign key constraint (pg only). */
            foreign_key_schema?: string | null;
          };
          /** The meta info. */
          meta?: {
            /** Unique identifier for the field in the `directus_fields` collection. */
            id?: number;
            /** Unique name of the collection this field is in. */
            collection?: string;
            /** Unique name of the field. Field name is unique within the collection. */
            field?: string;
            /** Transformation flag for field */
            special?: string[] | null;
            /** What interface is used in the admin app to edit the value for this field. */
            'system-interface'?: string | null;
            /** Options for the interface that's used. This format is based on the individual interface. */
            options?: { [key: string]: any } | null;
            /** What display is used in the admin app to display the value for this field. */
            display?: string | null;
            /** Options for the display that's used. This format is based on the individual display. */
            display_options?: { [key: string]: any } | null;
            /** If the field can be altered by the end user. Directus system fields have this value set to `true`. */
            locked?: boolean;
            /** Prevents the user from editing the value in the field. */
            readonly?: boolean;
            /** If this field should be hidden. */
            hidden?: boolean;
            /** Sort order of this field on the edit page of the admin app. */
            sort?: number | null;
            /** Width of the field on the edit form. */
            width?:
              | ('half' | 'half-left' | 'half-right' | 'full' | 'fill')
              | null;
            /** What field group this field is part of. */
            group?: number | null;
            /** Key value pair of `<language>: <translation>` that allows the user to change the displayed name of the field in the admin app. */
            translation?: { [key: string]: any } | null;
            /** A user provided note for the field. Will be rendered alongside the interface on the edit page. */
            note?: string | null;
          } | null;
        };
      };
    };
  };
  /** Retrieves the details of a single field in a given collection. */
  getCollectionField: {
    parameters: {
      path: {
        /** Unique identifier of the collection the item resides in. */
        collection: string;
        /** Unique identifier of the field. */
        id: string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Fields'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing field. */
  deleteField: {
    parameters: {
      path: {
        /** Unique identifier of the collection the item resides in. */
        collection: string;
        /** Unique identifier of the field. */
        id: string;
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing field. */
  updateField: {
    parameters: {
      path: {
        /** Unique identifier of the collection the item resides in. */
        collection: string;
        /** Unique identifier of the field. */
        id: string;
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Fields'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Unique name of the field. Field name is unique within the collection. */
          field?: string;
          /** Directus specific data type. Used to cast values in the API. */
          type?: string;
          /** The schema info. */
          schema?: {
            /** The name of the field. */
            name?: string;
            /** The collection of the field. */
            table?: string;
            /** The type of the field. */
            type?: string;
            /** The default value of the field. */
            default_value?: string | null;
            /** The max length of the field. */
            max_length?: number | null;
            /** If the field is nullable. */
            is_nullable?: boolean;
            /** If the field is primary key. */
            is_primary_key?: boolean;
            /** If the field has auto increment. */
            has_auto_increment?: boolean;
            /** Related column from the foreign key constraint. */
            foreign_key_column?: string | null;
            /** Related table from the foreign key constraint. */
            foreign_key_table?: string | null;
            /** Comment as saved in the database. */
            comment?: string | null;
            /** Database schema (pg only). */
            schema?: string;
            /** Related schema from the foreign key constraint (pg only). */
            foreign_key_schema?: string | null;
          };
          /** The meta info. */
          meta?: {
            /** Unique identifier for the field in the `directus_fields` collection. */
            id?: number;
            /** Unique name of the collection this field is in. */
            collection?: string;
            /** Unique name of the field. Field name is unique within the collection. */
            field?: string;
            /** Transformation flag for field */
            special?: string[] | null;
            /** What interface is used in the admin app to edit the value for this field. */
            'system-interface'?: string | null;
            /** Options for the interface that's used. This format is based on the individual interface. */
            options?: { [key: string]: any } | null;
            /** What display is used in the admin app to display the value for this field. */
            display?: string | null;
            /** Options for the display that's used. This format is based on the individual display. */
            display_options?: { [key: string]: any } | null;
            /** If the field can be altered by the end user. Directus system fields have this value set to `true`. */
            locked?: boolean;
            /** Prevents the user from editing the value in the field. */
            readonly?: boolean;
            /** If this field should be hidden. */
            hidden?: boolean;
            /** Sort order of this field on the edit page of the admin app. */
            sort?: number | null;
            /** Width of the field on the edit form. */
            width?:
              | ('half' | 'half-left' | 'half-right' | 'full' | 'fill')
              | null;
            /** What field group this field is part of. */
            group?: number | null;
            /** Key value pair of `<language>: <translation>` that allows the user to change the displayed name of the field in the admin app. */
            translation?: { [key: string]: any } | null;
            /** A user provided note for the field. Will be rendered alongside the interface on the edit page. */
            note?: string | null;
          } | null;
        };
      };
    };
  };
  /** List the files. */
  getFiles: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Files'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new file */
  createFile: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Files'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json': {
          data?: string;
        };
      };
    };
  };
  /** Retrieve a single file by unique identifier. */
  getFile: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Files'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Delete an existing file. */
  deleteFile: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Update an existing file. */
  updateFile: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Files'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json': { [key: string]: any };
      };
    };
  };
  /** List the folders. */
  getFolders: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Folders'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new folder. */
  createFolder: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Folders'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Name of the folder. */
          name: string;
          /** Unique identifier of the parent folder. This allows for nested folders. */
          parent?: number;
        };
      };
    };
  };
  /** Retrieve a single folder by unique identifier. */
  getFolder: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Folders'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing folder */
  deleteFolder: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing folder */
  updateFolder: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Folders'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Name of the folder. Can't be null or empty. */
          name?: string;
          /** Unique identifier of the parent folder. This allows for nested folders. */
          parent?: number;
        };
      };
    };
  };
  /** List all permissions. */
  getPermissions: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
        /** Cursor for use in pagination. Often used in combination with limit. */
        page?: components['parameters']['Page'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Permissions'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new permission. */
  createPermission: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Permissions'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** What collection this permission applies to. */
          collection?: string;
          /** If the user can post comments. */
          comment?: 'none' | 'create' | 'update' | 'full';
          /** If the user can create items. */
          create?: 'none' | 'full';
          /** If the user can update items. */
          delete?: 'none' | 'mine' | 'role' | 'full';
          /** If the user is required to leave a comment explaining what was changed. */
          explain?: 'none' | 'create' | 'update' | 'always';
          /** If the user can read items. */
          read?: 'none' | 'mine' | 'role' | 'full';
          /** Unique identifier of the role this permission applies to. */
          role?: number;
          /** Explicitly denies read access for specific fields. */
          read_field_blacklist?: string[];
          /** What status this permission applies to. */
          status?: string;
          /** Explicitly denies specific statuses to be used. */
          status_blacklist?: string[];
          /** If the user can update items. */
          update?: 'none' | 'mine' | 'role' | 'full';
          /** Explicitly denies write access for specific fields. */
          write_field_blacklist?: string[];
        };
      };
    };
  };
  /** List the permissions that apply to the current user. */
  getMyPermissions: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Permissions'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Retrieve a single permissions object by unique identifier. */
  getPermission: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Permissions'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing permission */
  deletePermission: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing permission */
  updatePermission: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Permissions'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** What collection this permission applies to. */
          collection?: { [key: string]: any };
          /** If the user can post comments. `full`. */
          comment?: 'none' | 'create' | 'update';
          /** If the user can create items. */
          create?: 'none' | 'full';
          /** If the user can update items. */
          delete?: 'none' | 'mine' | 'role' | 'full';
          /** If the user is required to leave a comment explaining what was changed. */
          explain?: 'none' | 'create' | 'update' | 'always';
          /** If the user can read items. */
          read?: 'none' | 'mine' | 'role' | 'full';
          /** Explicitly denies read access for specific fields. */
          read_field_blacklist?: { [key: string]: any };
          /** Unique identifier of the role this permission applies to. */
          role?: { [key: string]: any };
          /** What status this permission applies to. */
          status?: { [key: string]: any };
          /** Explicitly denies specific statuses to be used. */
          status_blacklist?: { [key: string]: any };
          /** If the user can update items. */
          update?: 'none' | 'mine' | 'role' | 'full';
          /** Explicitly denies write access for specific fields. */
          write_field_blacklist?: { [key: string]: any };
        };
      };
    };
  };
  /** List the presets. */
  getPresets: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** Cursor for use in pagination. Often used in combination with limit. */
        page?: components['parameters']['Page'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Presets'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Create a new preset. */
  createPreset: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Presets'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** What collection this collection preset is used for. */
          collection: string;
          /** Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark. */
          title?: string;
          /** The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role. */
          role?: string;
          /** What the user searched for in search/filter in the header bar. */
          search?: string;
          filters?: {
            key?: string;
            field?: string;
            operator?: string;
            value?: number;
          }[];
          /** Name of the view type that is used. */
          layout?: string;
          /** Layout query that's saved per layout type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters. */
          layout_query?: string;
          /** Options of the views. The properties in here are controlled by the layout. */
          layout_options?: string;
        };
      };
    };
  };
  /** Retrieve a single preset by unique identifier. */
  getPreset: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Presets'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Delete an existing preset. */
  deletePreset: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
    };
  };
  /** Update an existing preset. */
  updatePreset: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Presets'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** What collection this collection preset is used for. */
          collection: string;
          /** Name for the bookmark. If this is set, the collection preset will be considered to be a bookmark. */
          title?: string;
          /** The unique identifier of a role in the platform. If user is null, this will be used to apply the collection preset or bookmark for all users in the role. */
          role?: number;
          /** What the user searched for in search/filter in the header bar. */
          search_query?: string;
          filters?: {
            field?: string;
            operator?: string;
            value?: number;
          }[];
          /** Name of the view type that is used. Defaults to tabular. */
          view_type?: string;
          /** View query that's saved per view type. Controls what data is fetched on load. These follow the same format as the JS SDK parameters. */
          view_query?: string;
          /** Options of the views. The properties in here are controlled by the layout. */
          view_options?: string;
          /** Key value pair of language-translation. Can be used to translate the bookmark title in multiple languages. */
          translation?: { [key: string]: any };
        };
      };
    };
  };
  /** List the relations. */
  getRelations: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
        /** Cursor for use in pagination. Often used in combination with limit. */
        page?: components['parameters']['Page'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Relations'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new relation. */
  createRelation: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Relations'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Collection that has the field that holds the foreign key. */
          collection_many?: string;
          /** Collection on the _one_ side of the relationship. */
          collection_one?: string;
          /** Foreign key. Field that holds the primary key of the related collection. */
          field_many?: string;
          /** Alias column that serves as the _one_ side of the relationship. */
          field_one?: string;
          /** Field on the junction table that holds the primary key of the related collection. */
          junction_field?: string;
        };
      };
    };
  };
  /** Retrieve a single relation by unique identifier. */
  getRelation: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Relations'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing relation. */
  deleteRelation: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing relation */
  updateRelation: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Relations'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Collection that has the field that holds the foreign key. */
          collection_many?: string;
          /** Collection on the _one_ side of the relationship. */
          collection_one?: string;
          /** Foreign key. Field that holds the primary key of the related collection. */
          field_many?: string;
          /** Alias column that serves as the _one_ side of the relationship. */
          field_one?: string;
          /** Field on the junction table that holds the primary key of the related collection. */
          junction_field?: string;
        };
      };
    };
  };
  /** List the revisions. */
  getRevisions: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
        /** Cursor for use in pagination. Often used in combination with limit. */
        page?: components['parameters']['Page'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Revisions'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Retrieve a single revision by unique identifier. */
  getRevision: {
    parameters: {
      path: {
        /** Index */
        id: components['parameters']['Id'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Revisions'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** List the roles. */
  getRoles: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
        /** Cursor for use in pagination. Often used in combination with limit. */
        page?: components['parameters']['Page'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Roles'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new role. */
  createRole: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Roles'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Description of the role. */
          description?: string;
          /** Whether or not this role enforces the use of 2FA. */
          enforce_2fa?: boolean;
          /** ID used with external services in SCIM. */
          external_id?: string;
          /** Array of IP addresses that are allowed to connect to the API as a user of this role. */
          ip_whitelist?: string[];
          /** Custom override for the admin app module bar navigation. */
          module_listing?: string;
          /** Name of the role. */
          name?: string;
        };
      };
    };
  };
  /** Retrieve a single role by unique identifier. */
  getRole: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Roles'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing role */
  deleteRole: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing role */
  updateRole: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Roles'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Description of the role. */
          description?: string;
          /** Whether or not this role enforces the use of 2FA. */
          enforce_2fa?: boolean;
          /** ID used with external services in SCIM. */
          external_id?: string;
          /** Array of IP addresses that are allowed to connect to the API as a user of this role. */
          ip_whitelist?: string[];
          /** Custom override for the admin app module bar navigation. */
          module_listing?: string;
          /** Name of the role. */
          name?: string;
        };
      };
    };
  };
  /** List the settings. */
  getSettings: {
    parameters: {
      query: {
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** Cursor for use in pagination. Often used in combination with limit. */
        page?: components['parameters']['Page'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Settings'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update the settings */
  updateSetting: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Settings'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': { [key: string]: any };
      };
    };
  };
  /** List the users. */
  getUsers: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** A limit on the number of objects that are returned. */
        limit?: components['parameters']['Limit'];
        /** How many items to skip when fetching data. */
        offset?: components['parameters']['Offset'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
        /** How to sort the returned items. `sort` is a CSV of fields used to sort the fetched items. Sorting defaults to ascending (ASC) order but a minus sign (` - `) can be used to reverse this to descending (DESC) order. Fields are prioritized by their order in the CSV. You can also use a ` ? ` to sort randomly. */
        sort?: components['parameters']['Sort'];
        /** Select items in collection by given conditions. */
        filter?: components['parameters']['Filter'];
        /** Filter by items that contain the given search query in one of their fields. */
        search?: components['parameters']['Search'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Users'][];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new user. */
  createUser: {
    parameters: {
      query: {
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Users'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Users'];
      };
    };
  };
  /** Retrieve a single user by unique identifier. */
  getUser: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Users'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing user */
  deleteUser: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing user */
  updateUser: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: { [key: string]: any };
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['Users'];
      };
    };
  };
  /** Invites one or more users to this project. It creates a user with an invited status, and then sends an email to the user with instructions on how to activate their account. */
  invite: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Users'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Email address or array of email addresses of the to-be-invited user(s). */
          email?: string;
        };
      };
    };
  };
  /** Accepts and enables an invited user using a JWT invitation token. */
  acceptInvite: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Users'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Accept invite token. */
          token?: string;
          /** Password of the user. */
          password?: string;
        };
      };
    };
  };
  /** Retrieve the currently authenticated user. */
  getMe: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Users'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update the currently authenticated user. */
  updateMe: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Users'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Updates the last used page field of the currently authenticated user. This is used internally to be able to open the Directus admin app from the last page you used. */
  updateLastUsedPageMe: {
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** Path of the page you used last. */
          last_page?: string;
        };
      };
    };
  };
  /** Enables two-factor authentication for the currently authenticated user. */
  meTfaEnable: {
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Disables two-factor authentication for the currently authenticated user. */
  meTfaDisable: {
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Get all webhooks. */
  getWebhooks: {
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Webhooks'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Create a new webhook. */
  createWebhook: {
    parameters: {
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Roles'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** The name of the webhook. */
          name?: string;
          /** Method used in the webhook. */
          method?: string;
          /** The url of the webhook. */
          url?: string;
          /** The status of the webhook. */
          status?: string;
          /** If yes, send the content of what was done */
          data?: boolean;
          /** The actions that triggers this webhook. */
          actions?: { [key: string]: any };
          /** The collections that triggers this webhook. */
          'system-collections'?: { [key: string]: any };
        };
      };
    };
  };
  /** Retrieve a single webhook by unique identifier. */
  getWebhook: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Webhooks'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Delete an existing webhook */
  deleteWebhook: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
    };
    responses: {
      /** Successful request */
      200: unknown;
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
  };
  /** Update an existing webhook */
  updateWebhook: {
    parameters: {
      path: {
        /** Unique identifier for the object. */
        id: components['parameters']['UUId'];
      };
      query: {
        /** Control what fields are being returned in the object. */
        fields?: components['parameters']['Fields'];
        /** What metadata to return in the response. */
        meta?: components['parameters']['Meta'];
      };
    };
    responses: {
      /** Successful request */
      200: {
        content: {
          'application/json': {
            data?: components['schemas']['Roles'];
          };
        };
      };
      401: components['responses']['UnauthorizedError'];
      404: components['responses']['NotFoundError'];
    };
    requestBody: {
      content: {
        'application/json': {
          /** The name of the webhook. */
          name?: string;
          /** Method used in the webhook. */
          method?: string;
          /** The url of the webhook. */
          url?: string;
          /** The status of the webhook. */
          status?: string;
          /** If yes, send the content of what was done */
          data?: boolean;
          /** The actions that triggers this webhook. */
          actions?: { [key: string]: any };
          /** The collections that triggers this webhook. */
          'system-collections'?: { [key: string]: any };
        };
      };
    };
  };
}

export type Collections = {
  article: components['schemas']['ItemsArticle'];
  article_category: components['schemas']['ItemsArticleCategory'];
  article_category_pivot: components['schemas']['ItemsArticleCategoryPivot'];
  audio: components['schemas']['ItemsAudio'];
  audio_category: components['schemas']['ItemsAudioCategory'];
  audio_category_pivot: components['schemas']['ItemsAudioCategoryPivot'];
  book: components['schemas']['ItemsBook'];
  book_author: components['schemas']['ItemsBookAuthor'];
  book_category: components['schemas']['ItemsBookCategory'];
  book_category_pivot: components['schemas']['ItemsBookCategoryPivot'];
  comment: components['schemas']['ItemsComment'];
  comment_entity: components['schemas']['ItemsCommentEntity'];
  document: components['schemas']['ItemsDocument'];
  document_category: components['schemas']['ItemsDocumentCategory'];
  document_category_pivot: components['schemas']['ItemsDocumentCategoryPivot'];
  image: components['schemas']['ItemsImage'];
  image_category: components['schemas']['ItemsImageCategory'];
  image_category_pivot: components['schemas']['ItemsImageCategoryPivot'];
  institute: components['schemas']['ItemsInstitute'];
  menu: components['schemas']['ItemsMenu'];
  page: components['schemas']['ItemsPage'];
  question: components['schemas']['ItemsQuestion'];
  question_category: components['schemas']['ItemsQuestionCategory'];
  question_category_pivot: components['schemas']['ItemsQuestionCategoryPivot'];
  question_type: components['schemas']['ItemsQuestionType'];
  reaction: components['schemas']['ItemsReaction'];
  reaction_entity: components['schemas']['ItemsReactionEntity'];
  reaction_type: components['schemas']['ItemsReactionType'];
  section: components['schemas']['ItemsSection'];
  theme: components['schemas']['ItemsTheme'];
  theme_page: components['schemas']['ItemsThemePage'];
  theme_page_section: components['schemas']['ItemsThemePageSection'];
  video: components['schemas']['ItemsVideo'];
  video_category: components['schemas']['ItemsVideoCategory'];
  video_category_pivot: components['schemas']['ItemsVideoCategoryPivot'];
  website: components['schemas']['ItemsWebsite'];
};
